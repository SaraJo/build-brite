// var five = require("../lib/johnny-five.js"),
//     board, accel;

// board = new five.Board();

// board.on("ready", function() {

//   var MMA8452_ADDRESS = 0x1D;
//   var OUT_X_MSB = 0x01;
//   var XYZ_DATA_CFG = 0x0E;
//   var WHO_AM_I = 0x0D;
//   var REGISTER = 0x2A;

//   // Sets full-scale range to +/-2, 4, or 8g. Used to calc real g values.
//   var GSCALE = 2;


//   function MMA8452() {
//     byte c = readRegister(WHO_AM_I);  // Read WHO_AM_I register
//     if (c == 0x2A) // WHO_AM_I should always be 0x2A
//     {
//       Serial.println("MMA8452Q is online...");
//     }
//     else
//     {
//       Serial.print("Could not connect to MMA8452Q: 0x");
//       Serial.println(c, HEX);
//       while(1) ; // Loop forever if communication doesn't happen
//     }



//     // Set up the full scale range to 2, 4, or 8g.
//     var fsr = GSCALE;
//     if ( fsr > 8 ) {
//       fsr = 8;
//     }
//     fsr >>= 2; // Neat trick, see page 22. 00 = 2G, 01 = 4A, 10 = 8G

//     this.standby({ addr: XYZ_DATA_CFG, bytes: [ fsr ] });


//     this.firmata.sendI2CReadRequest( REGISTER, 1, function( data ) {
//       console.log( "active", data );

//       this.firmata.sendI2CWriteRequest( REGISTER, [ data | 0x01 ] );
//     }.bind(this));

//   }


//   MMA8452.prototype.standby = function( opts, callback ) {
//     var isReadFirst = false,
//         next;

//     if ( callback ) {
//       isReadFirst = true;
//     }

//     this.firmata.sendI2CReadRequest( REGISTER, 1, function( data ) {
//       this.firmata.sendI2CWriteRequest( REGISTER, [ data & ~(0x01) ] );

//       if ( isReadFirst ) {
//         this.firmata.sendI2CReadRequest( opts.addr, opts.bytes, callback );
//       } else {
//         this.firmata.sendI2CWriteRequest( opts.addr, opts.bytes );
//       }
//     }.bind(this));
//   };



//   // void loop()
//   // {
//   //   int accelCount[3];  // Stores the 12-bit signed value
//   //   readAccelData(accelCount);  // Read the x/y/z adc values

//   //   // Now we'll calculate the accleration value into actual g's
//   //   float accelG[3];  // Stores the real accel value in g's
//   //   for (int i = 0 ; i < 3 ; i++)
//   //   {
//   //     accelG[i] = (float) accelCount[i] / ((1<<12)/(2*GSCALE));  // get actual g value, this depends on scale being set
//   //   }

//   //   // Print out values
//   //   for (int i = 0 ; i < 3 ; i++)
//   //   {
//   //     Serial.print(accelG[i], 4);  // Print g values
//   //     Serial.print("\t");  // tabs in between axes
//   //   }
//   //   Serial.println();

//   //   delay(10);  // Delay here for visibility
//   // }

//   // void readAccelData(int *destination)
//   // {
//   //   byte rawData[6];  // x/y/z accel register data stored here

//   //   readRegisters(OUT_X_MSB, 6, rawData);  // Read the six raw data registers into data array

//   //   // Loop to calculate 12-bit ADC and g value for each axis
//   //   for(int i = 0; i < 3 ; i++)
//   //   {
//   //     int gCount = (rawData[i*2] << 8) | rawData[(i*2)+1];  //Combine the two 8 bit registers into one 12-bit number
//   //     gCount >>= 4; //The registers are left align, here we right align the 12-bit integer

//   //     // If the number is negative, we have to make it so manually (no 12-bit data type)
//   //     if (rawData[i*2] > 0x7F)
//   //     {
//   //       gCount = ~gCount + 1;
//   //       gCount *= -1;  // Transform into negative 2's complement #
//   //     }

//   //     destination[i] = gCount; //Record this gCount into the 3 int array
//   //   }
//   // }





//   // // Read bytesToRead sequentially, starting at addressToRead into the dest byte array
//   // void readRegisters(byte addressToRead, int bytesToRead, byte * dest)
//   // {
//   //   Wire.beginTransmission(MMA8452_ADDRESS);
//   //   Wire.write(addressToRead);
//   //   Wire.endTransmission(false); //endTransmission but keep the connection active

//   //   Wire.requestFrom(MMA8452_ADDRESS, bytesToRead); //Ask for bytes, once done, bus is released by default

//   //   while(Wire.available() < bytesToRead); //Hang out until we get the # of bytes we expect

//   //   for(int x = 0 ; x < bytesToRead ; x++)
//   //     dest[x] = Wire.read();
//   // }

//   // // Read a single byte from addressToRead and return it as a byte
//   // byte readRegister(byte addressToRead)
//   // {
//   //   Wire.beginTransmission(MMA8452_ADDRESS);
//   //   Wire.write(addressToRead);
//   //   Wire.endTransmission(false); //endTransmission but keep the connection active

//   //   Wire.requestFrom(MMA8452_ADDRESS, 1); //Ask for 1 byte, once done, bus is released by default

//   //   while(!Wire.available()) ; //Wait for the data to come back
//   //   return Wire.read(); //Return this one byte
//   // }

//   // // Writes a single byte (dataToWrite) into addressToWrite
//   // void writeRegister(byte addressToWrite, byte dataToWrite)
//   // {
//   //   Wire.beginTransmission(MMA8452_ADDRESS);
//   //   Wire.write(addressToWrite);
//   //   Wire.write(dataToWrite);
//   //   Wire.endTransmission(); //Stop transmitting
//   // }




// });
